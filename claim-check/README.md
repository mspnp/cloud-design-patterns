# Claim-Check Pattern

| :notebook: | This content supports the [Claim-Check design pattern](https://docs.microsoft.com/azure/architecture/patterns/claim-check) found on Microsoft Docs. Please see it for additional context. |
|-----------|:--------------------------|

## [Automatic Tag Generation, Queues as Message Bus](./code-samples/sample-1/)

> Technologies used: Azure Blob Storage, Azure Event Grid, Azure Functions, Azure Blob Queue, .NET

In this example we're using Blob Store to store data, but any service that supports Event Grid integration can be used too. A client just needs to drop the payload to be shared into the designated Azure Blob Store and Event Grid will automatically generate a Tag/Reference and send it to one of the supported message bus. In this sample the message bus is created using Azure Storage Queues. This allows a client application to poll the queue, get the message and then use the stored reference data to download the payload directly from Azure Blob Storage.
The same message, without the need to go through a message bus, can also be directly consumed via Azure Function, leveraging in this case the serverless nature of both Azure Event Grid and Azure Functions.

## [Automatic Tag Generation, Event Hubs as Message Bus](./code-samples/sample-2/)

> Technologies used: Azure Blob Storage, Azure Event Grid, Azure Event Hub, .NET

Very similarly to the previous sample, a reference message is automatically generated by [Event Grid](https://azure.microsoft.com/services/event-grid/) as soon as a payload is dropped in the designated Azure Blob Storage. Here the message bus is implemented via Event Hub, so that a client can register itself to be notified each time there is a message in the bus.
Event Hub is also configured so that it [automatically archives](https://docs.microsoft.com/azure/event-hubs/event-hubs-capture-overview) received messages that are then available as an AVRO file easily queryable using tools like Apache Spark, Apache Drill or any of the Avro libraries available.

## [Plugin support, Service Bus as Message Bus](./code-samples/sample-3/)

> Technologies used: Azure Blob Storage, Azure Service Bus, .NET

This sample takes advantage of the [ServiceBus.AttachmentPlugin](https://www.nuget.org/packages/ServiceBus.AttachmentPlugin) which brings the claim check pattern implementation to Service Bus. The plugin is used to convert any message body into an attachment which gets stored in Azure Blob Storage on message send. Internally, service bus message is used to act as a notification queue which can subscribed on to read the message. On message receive, the plugin makes it possible to directly read the message data from blob storage in the consumer. You can then chose how you want to process the message further. The good thing about this approach is, it obscures the actual claim check workflow from the end user.

## [Manual Tagging](./code-samples/sample-4/)

> Technologies used: Azure Blob Storage, Azure Event Hubs with Kafka, .NET

The reason this example uses Event Hubs with Kafka is to demonstrate the ease of using other Azure services like Azure Blob Storage, Azure functions etc. with a different messaging protocol like Kafka from your existing Kafka clients to implement the claim check messaging pattern. This sample consists of a Kafka client which drops the payload in the designated Azure Blob Storage and creates a notification message with location details to be sent to the consumer. The notification message is sent using [Event Hubs with Kafka enabled](https://docs.microsoft.com/azure/event-hubs/event-hubs-create-kafka-enabled). The consumer is notified each time these is a message in the Event Hub and can access the payload using the location information in the message received.