# Priority Queue pattern example

This directory contains an example of the [Priority Queue pattern](https://learn.microsoft.com/azure/architecture/patterns/priority-queue).

This example demonstrates how priority queues can be implemented by using Service Bus topics and subscriptions. A time-triggered Azure Function is responsible for sending messages to a topic, each with a priority assigned. The receiving Azure Functions read messages from subscriptions that have the corresponding priority. 

For local execution, the sample demonstrates the producer/consumer model, where each consumer processes only one type of message based on its priority.

In the Azure Deployment, the _PriorityQueueConsumerHigh_ Azure function could scale out to 200 instances, while the _PriorityQueueConsumerLow_ Azure function runs only with one instance. It simulates high priority messages being read from the queue more urgently than low priority messages.

The Azure deployment also demonstrates operational aspects of applications running on Azure. Monitoring tools are essential to understand how the sample operates. Azure Functions in the solution **must** be configured to use the diagnostics mechanism. Otherwise, trace information generated by the example will not be visible.

## :rocket: Deployment guide

Install the prerequisites and follow the steps to deploy and run an example of the Priority Queue pattern.

### Prerequisites

- Permission to create a new resource group and resources in an [Azure subscription](https://azure.com/free).
- [Git](https://git-scm.com/downloads)
- [Azure CLI](https://learn.microsoft.com/cli/azure/install-azure-cli)
- [.NET 9 SDK](https://dotnet.microsoft.com/download/dotnet/9.0)
- [Azure Functions Core Tools v4.x](https://learn.microsoft.com/azure/azure-functions/functions-run-local#install-the-azure-functions-core-tools)

### Steps

1. Clone the repository

   Open a terminal, clone the repository, and navigate to the `priority-queue` directory.

   ```shell
   git clone https://github.com/mspnp/cloud-design-patterns.git
   cd cloud-design-patterns
   cd priority-queue
   ```

1. Log into Azure and create an empty resource group.

   Create an empty resource group to hold the resources for this example. The location you select in the resource group creation command below is the Azure region that your resources will be deployed in; modify as needed.

   ```bash
   az login
   az account set -s <Name or ID of subscription>

   LOCATION=eastus2
   RESOURCE_GROUP_NAME=rg-priority-queue-${LOCATION}
   az group create -n $RESOURCE_GROUP_NAME -l $LOCATION
   ```

1. Deploy the supporting Azure resources.

   ```bash
   CURRENT_USER_OBJECT_ID=$(az ad signed-in-user show -o tsv --query id)
   SERVICE_BUS_NAMESPACE_NAME="sbns-priority-queue-$(LC_ALL=C tr -dc 'a-z0-9' < /dev/urandom | fold -w 7 | head -n 1)"

   # This takes about two minutes
   az deployment group create -n deploy-priority-queue -f bicep/main.bicep -g $RESOURCE_GROUP_NAME -p queueNamespaces=$SERVICE_BUS_NAMESPACE_NAME principalId=$CURRENT_USER_OBJECT_ID
   ```

1. Configure the samples to use the created Azure resources.

   ```bash
   # Retrieve the primary connection string for the Service Bus namespace.
   SERVICE_BUS_FULLY_QUALIFIED_NAMESPACE="${SERVICE_BUS_NAMESPACE_NAME}.servicebus.windows.net"

   sed "s|{SERVICE_BUS_FULLY_QUALIFIED_NAMESPACE}|${SERVICE_BUS_FULLY_QUALIFIED_NAMESPACE}|g" ./PriorityQueueSender/local.settings.template.json > ./PriorityQueueSender/local.settings.json
   sed "s|{SERVICE_BUS_FULLY_QUALIFIED_NAMESPACE}|${SERVICE_BUS_FULLY_QUALIFIED_NAMESPACE}|g" ./PriorityQueueConsumerHigh/local.settings.template.json > ./PriorityQueueConsumerHigh/local.settings.json
   sed "s|{SERVICE_BUS_FULLY_QUALIFIED_NAMESPACE}|${SERVICE_BUS_FULLY_QUALIFIED_NAMESPACE}|g" ./PriorityQueueConsumerLow/local.settings.template.json > ./PriorityQueueConsumerLow/local.settings.json
   ```

1. [Run Azurite](https://learn.microsoft.com/azure/storage/common/storage-use-azurite#run-azurite) blob storage emulation service.

   > Azure Functions require an Azure Storage account as a backing resource. When running locally, you can use Azurite, the local storage emulator, to fulfill this requirement.
Alternatively, you may configure the AzureWebJobsStorage setting to use a real Azure Storage account if preferred.

1. Launch the Azure Function PriorityQueueSender to generate Low and High messages.  

   ```bash
   cd ./PriorityQueueSender
   func start
   ```

1. In a new terminal, launch the Azure Function PriorityQueueConsumerLow to consume messages.  

   ```bash
   cd ./PriorityQueueConsumerLow
   func start -p 15000
   ```

  > Please note: For demo purposes, the sample application will write content to the screen.

1. In a new terminal, launch the Azure Function PriorityQueueConsumerHigh to consume messages.  

   ```bash
   cd ./PriorityQueueConsumerHigh 
   func start -p 15001
   ```

  > Please note: For demo purposes, the sample application will write content to the screen.

## Deploy the example to Azure (Optional)

```bash
   # This takes about five minutes
   az deployment group create -n deploy-priority-queue-sites -f bicep/azure/azure-function-app.bicep -g $RESOURCE_GROUP_NAME -p serviceBusNamespaceName=$SERVICE_BUS_NAMESPACE_NAME 

   # Deploy using Azure Functions Core Tools 
   cd .\PriorityQueueSender\
   func azure functionapp publish funcPriorityQueueSender
   cd ..
   cd .\PriorityQueueConsumerLow\
   func azure functionapp publish funcPriorityQueueConsumerLow
   cd ..
   cd .\PriorityQueueConsumerHigh\
   func azure functionapp publish funcPriorityQueueConsumerHigh
```

```
   // Recent requests with key details
   requests
   | project timestamp, operation_Name, cloud_RoleName, id, success, resultCode, duration, operation_Id
   | order by timestamp desc

   // Count of requests by operation name
   requests
   | summarize RequestCount = count() by operation_Name
   | order by RequestCount desc

   // Traces filtered by keywords
   traces
   | where operation_Name contains "High"

   traces
   | where operation_Name contains "Low"

   traces
   | where operation_Name contains "Sender"
```


To deploy the example to Azure, you need to publish each Azure Functions to Azure. You can do so from Visual Studio by right clicking each function and selecting `Publish` from the menu. Use the same resource group and region from earlier. Be sure to enable Application Insights.

Once each Azure Function is published, a new App Setting must be added to store the Service Bus fully qualified namespace. This is the same value that was used in the `SERVICE_BUS_FULLY_QUALIFIED_NAMESPACE` variable in the previous steps. The solution is using Managed Identity to access Service Bus.

For each Azure Function, run the following:

```bash
az webapp config appsettings set -n <function_app_name> -g $RESOURCE_GROUP_NAME --settings ServiceBusConnection__fullyQualifiedNamespace=$SERVICE_BUS_FULLY_QUALIFIED_NAMESPACE
```

Once the Azure Functions are deployed you need to restrict the maximum number of instances the `PriorityQueueConsumerLow` function can scale out to.

From the Azure portal:

- Visit the Function App that contains `PriorityQueueConsumerLow`
- Navigate to Scale Out on the left menu
- On the App Scale Out dialog, set the `Enforce Scale Out Limit` to `Yes`
- Set the `Maximum Scale Out Limit` to `1` instance

Once the Azure Functions are deployed you can visit Application Insights to view the most recent activity for each function.

## :broom: Clean up resources

Be sure to delete Azure resources when not using them. Since all resources were deployed into a new resource group, you can simply delete the resource group.

```bash
az group delete -n $RESOURCE_GROUP_NAME -y
```
