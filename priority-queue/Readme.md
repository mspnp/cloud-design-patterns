# Priority Queue pattern example

This directory contains an example of the [Priority Queue pattern](https://learn.microsoft.com/azure/architecture/patterns/priority-queue).

This example demonstrates how priority queues can be implemented by using Service Bus topics and subscriptions. A time-triggered Azure Function is responsible for sending messages to a topic, each with a priority assigned. The receiving Azure Functions read messages from subscriptions that have the corresponding priority. 

For local execution, the sample demonstrates the producer/consumer model, where each consumer processes only one type of message based on its priority.

In the Azure Deployment, the _PriorityQueueConsumerHigh_ Azure function could scale out to 200 instances, while the _PriorityQueueConsumerLow_ Azure function could scale out only to 40 instances. It simulates high priority messages being read from the queue more urgently than low priority messages.

The Azure deployment also demonstrates operational aspects of applications running on Azure. Monitoring tools are essential to understand how the sample operates. Azure Functions in the solution **must** be configured to use the diagnostics mechanism. Otherwise, trace information generated by the example will not be visible.

## :rocket: Deployment guide

Install the prerequisites and follow the steps to deploy and run an example of the Priority Queue pattern.

### Prerequisites

- Permission to create a new resource group and resources in an [Azure subscription](https://azure.com/free).
- [Git](https://git-scm.com/downloads)
- [Azure CLI](https://learn.microsoft.com/cli/azure/install-azure-cli)
- [.NET 9 SDK](https://dotnet.microsoft.com/download/dotnet/9.0)
- [Azure Functions Core Tools v4.x](https://learn.microsoft.com/azure/azure-functions/functions-run-local#install-the-azure-functions-core-tools)

### Steps

1. Clone the repository

   Open a terminal, clone the repository, and navigate to the `priority-queue` directory.

   ```shell
   git clone https://github.com/mspnp/cloud-design-patterns.git
   cd cloud-design-patterns
   cd priority-queue
   ```

1. Log into Azure and create an empty resource group.

   Create an empty resource group to hold the resources for this example. The location you select in the resource group creation command below is the Azure region that your resources will be deployed in; modify as needed.

   ```bash
   az login
   az account set -s <Name or ID of subscription>

   LOCATION=eastus2
   RESOURCE_GROUP_NAME=rg-priority-queue-${LOCATION}
   az group create -n $RESOURCE_GROUP_NAME -l $LOCATION
   ```

1. Deploy the supporting Azure resources.

   ```bash
   CURRENT_USER_OBJECT_ID=$(az ad signed-in-user show -o tsv --query id)
   SERVICE_BUS_NAMESPACE_NAME="sbns-priority-queue-$(LC_ALL=C tr -dc 'a-z0-9' < /dev/urandom | fold -w 7 | head -n 1)"

   # This takes about two minutes
   az deployment group create -n deploy-priority-queue -f bicep/main.bicep -g $RESOURCE_GROUP_NAME -p queueNamespaces=$SERVICE_BUS_NAMESPACE_NAME principalId=$CURRENT_USER_OBJECT_ID
   ```

1. Configure the samples to use the created Azure resources.

   ```bash
   # Retrieve the primary connection string for the Service Bus namespace.
   SERVICE_BUS_FULLY_QUALIFIED_NAMESPACE="${SERVICE_BUS_NAMESPACE_NAME}.servicebus.windows.net"

   sed "s|{SERVICE_BUS_FULLY_QUALIFIED_NAMESPACE}|${SERVICE_BUS_FULLY_QUALIFIED_NAMESPACE}|g" ./PriorityQueueSender/local.settings.template.json > ./PriorityQueueSender/local.settings.json
   sed "s|{SERVICE_BUS_FULLY_QUALIFIED_NAMESPACE}|${SERVICE_BUS_FULLY_QUALIFIED_NAMESPACE}|g" ./PriorityQueueConsumerHigh/local.settings.template.json > ./PriorityQueueConsumerHigh/local.settings.json
   sed "s|{SERVICE_BUS_FULLY_QUALIFIED_NAMESPACE}|${SERVICE_BUS_FULLY_QUALIFIED_NAMESPACE}|g" ./PriorityQueueConsumerLow/local.settings.template.json > ./PriorityQueueConsumerLow/local.settings.json
   ```

1. [Run Azurite](https://learn.microsoft.com/azure/storage/common/storage-use-azurite#run-azurite) blob storage emulation service.

   > Azure Functions require an Azure Storage account as a backing resource. When running locally, you can use Azurite, the local storage emulator, to fulfill this requirement.
Alternatively, you may configure the AzureWebJobsStorage setting to use a real Azure Storage account if preferred.

1. Launch the Azure Function PriorityQueueSender to generate Low and High messages.  

   ```bash
   cd ./PriorityQueueSender
   func start
   ```

1. In a new terminal, launch the Azure Function PriorityQueueConsumerLow to consume messages.  

   ```bash
   cd ./PriorityQueueConsumerLow
   func start -p 15000
   ```

  > Please note: For demo purposes, the sample application will write content to the screen.

1. In a new terminal, launch the Azure Function PriorityQueueConsumerHigh to consume messages.  

   ```bash
   cd ./PriorityQueueConsumerHigh 
   func start -p 15001
   ```

  > Please note: For demo purposes, the sample application will write content to the screen.

## Deploy the example to Azure (Optional)

This Bicep template sets up the core infrastructure for a priority-based message processing system using Azure Functions. It creates a secure Storage Account, an Application Insights instance for monitoring, and uses a previously created Service Bus namespace to enable communication between the sender and consumer functions. The deployment includes three Azure Function Apps: one sender and two consumers, each with different scaling limits to simulate message prioritization.
The funcPriorityQueueConsumerHigh function can scale out to 200 instances, allowing it to process high-priority messages quickly. The funcPriorityQueueConsumerLow function is limited to 40 instances, handling lower-priority messages with less urgency. All function apps use the FlexConsumption plan and are connected to Application Insights for diagnostics and monitoring. Role assignments are configured to securely grant access to the Service Bus and Storage resources using managed identities.
All Azure Function Apps share the same Storage Account and Application Insights instance (It is essential to understand how the sample operates), which centralizes observability and logging.

```bash
   # This takes about three minutes
   az deployment group create -n deploy-priority-queue-sites -f bicep/azure/azure-function-apps.bicep -g $RESOURCE_GROUP_NAME -p serviceBusNamespaceName=$SERVICE_BUS_NAMESPACE_NAME 
```
After deploying the infrastructure, you need to publish each Azure Function to its corresponding Function App using Azure Functions Core Tools:

```bash
   cd .\PriorityQueueSender\
   func azure functionapp publish funcPriorityQueueSender
   cd ..
   cd .\PriorityQueueConsumerLow\
   func azure functionapp publish funcPriorityQueueConsumerLow
   cd ..
   cd .\PriorityQueueConsumerHigh\
   func azure functionapp publish funcPriorityQueueConsumerHigh
```

You can view the maximum scaling configuration in the Azure Portal. Go to each Function App, then under Settings, select Scale and concurrency. There, you'll see the Maximum instance count setting.

Once the Azure Functions are deployed, you can use Application Insights to monitor their activity. In the Azure portal, go to the Application Insights resource, then select Logs. Switch to KQL mode and run the following queries to view trace logs for each function:

```
   // Traces for the High priority consumer
   traces
   | where operation_Name contains "High"

   // Traces for the Low priority consumer
   traces
   | where operation_Name contains "Low"

   // Traces for the Sender function
   traces
   | where operation_Name contains "Sender"
```
In addition to viewing trace logs, you can also use Application Insights to analyze request-level data for each Azure Function. The following queries help you inspect recent requests and understand how frequently each function is being called:

```
   // Recent requests with key details
   requests
   | project timestamp, operation_Name, cloud_RoleName, id, success, resultCode, duration, operation_Id
   | order by timestamp desc

   // Count of requests by Function
   requests
   | summarize RequestCount = count() by operation_Name
   | order by RequestCount desc
```
## :broom: Clean up resources

Be sure to delete Azure resources when not using them. Since all resources were deployed into a new resource group, you can simply delete the resource group.

```bash
az group delete -n $RESOURCE_GROUP_NAME -y
```
